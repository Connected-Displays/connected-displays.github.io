<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Connected Displays</title>
    <link>http://www.connected-displays.com/post/</link>
    <description>Recent content in Posts on Connected Displays</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 04 Feb 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://www.connected-displays.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Tutorial - Umbrella Reminder with Particle Photon and Forecast.io</title>
      <link>http://www.connected-displays.com/post/photon-rain-led-tutorial/</link>
      <pubDate>Thu, 04 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://www.connected-displays.com/post/photon-rain-led-tutorial/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;banner.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;I live in NYC and the weather can change suddenly.  It may look nice outside my window when I&amp;rsquo;m getting ready to leave, but a storm could be inbound.  I&amp;rsquo;d like to have something that tells me to &amp;ldquo;bring your umbrella&amp;rdquo; right next to the door.&lt;/p&gt;

&lt;p&gt;This is my first project done with the &lt;a href=&#34;https://www.particle.io/prototype&#34;&gt;Particle Photon&lt;/a&gt;, and because I couldn&amp;rsquo;t find a comprehensive tutorial on this type of project, I wrote it up in tutorial form. The tutorial demonstrates polling for data from a third-party API using Webhooks, and requires no extra parts or assembly to get going.&lt;/p&gt;

&lt;p&gt;I backed the initial &lt;a href=&#34;https://www.kickstarter.com/projects/sparkdevices/spark-core-wi-fi-for-everything-arduino-compatible&#34;&gt;Kickstarter campaign&lt;/a&gt; for the Spark Core back in 2013 but never made use of the Core as it didn&amp;rsquo;t have enough memory for the projects I was working on at the time.  I kept watching for an announcement of a V2 Spark Core, and when the Photon was announced I preordered a few immediately.  While it&amp;rsquo;s not needed for this project, the Photon has plenty of memory and a better WiFi chipset than the Core, and at $20 is a great value.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re replicating this project, all you need to buy is a Photon.  Hopefully you already have a computer, USB micro-B cable, and smartphone capable of running the Particle app to initially configure the Photon.&lt;/p&gt;

&lt;h2 id=&#34;getting-started-blink-an-led:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Getting Started - Blink an LED&lt;/h2&gt;

&lt;p&gt;Follow the &lt;a href=&#34;https://docs.particle.io/guide/getting-started/start/photon/&#34;&gt;Getting Started&lt;/a&gt; section of the Photon Guide to create a Particle.io account, connect the Photon to your WiFi network using the smartphone app, and give it a name (&amp;ldquo;Umbrella_Light&amp;rdquo;).  I didn’t have any trouble setting up WiFi using the app, but some friends have had trouble using the app.  There is a way to add the Photon to your account and connect it to your WiFi network using USB after &lt;a href=&#34;https://docs.particle.io/guide/tools-and-features/cli/photon/#installing&#34;&gt;installing the Particle CLI tool.&lt;/a&gt; CLI is needed later in this tutorial, so it you want to skip the Particle app and setup everything with CLI, you&amp;rsquo;re not wasting any time.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;DraggedImage.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Next let&amp;rsquo;s go to &lt;a href=&#34;https://build.particle.io/build&#34;&gt;Particle Build&lt;/a&gt;, the web IDE for Particle products that will let you write code, compile, and update your Photon all from a browser.  If you&amp;rsquo;ve used the Arduino IDE before, Build is a similar concept, only everything is done in a browser and programming is done over WiFi not USB.&lt;/p&gt;

&lt;p&gt;Start by opening the Devices tab, find &amp;ldquo;Umbrella_Light&amp;rdquo;, and make sure it&amp;rsquo;s online (circle &lt;a href=&#34;https://docs.particle.io/guide/getting-started/modes/photon/#connected&#34;&gt;breathing cyan&lt;/a&gt; next to the name.  If you’re already a Particle user and there are multiple devices in your list, hover to the left of the name and click to show a yellow star.  The device with a star will get flashed with new firmware when you use the Flash function.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;DraggedImage-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now go to the Code tab.  Click on the Example app called &amp;ldquo;BLINK AN LED&amp;rdquo;, then the button at the top “USE THIS EXAMPLE&amp;rdquo;.  Rename the app from &amp;ldquo;BLINK AN LED&amp;rdquo; to &amp;ldquo;UMBRELLA-LIGHT&amp;rdquo; by clicking on the name.  Now click on each of the icons in the upper left from bottom to top: Save, Verify, Flash, looking at the status that shows up below the code before continuing to the next one.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;DraggedImage-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Your Photon&amp;rsquo;s RGB LED should go through &lt;a href=&#34;https://docs.particle.io/guide/getting-started/modes/photon/&#34;&gt;several changes&lt;/a&gt; as firmware is loading and it starts up.  If this is your first time using the Photon, the base firmware may need to be updated which can take a minute or more.  You might see blinking magenta, then blinking of other colors, but in the end the LED should show Breathing Cyan (connected).  The Blue LED next to pin D7 should now be blinking on and off.  Your first program is loaded and running!&lt;/p&gt;

&lt;h2 id=&#34;customizing-the-firmware:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Customizing the Firmware&lt;/h2&gt;

&lt;h3 id=&#34;leds:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;LEDs&lt;/h3&gt;

&lt;p&gt;As I’m walking out my door, I want to know at a glance if there’s a chance of rain in the next four hours, so I can make a decision on if I should bring an umbrella.  I figure there are four states that can easily be displayed on the Blue LED, and recognizable at a glance:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;State&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;Blue LED&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Bring an umbrella&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ON&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Chance of rain&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Short Pulse&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;No Rain&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;OFF&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Can&amp;rsquo;t Connect&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Flashing Fast&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;This code added before &lt;code&gt;setup()&lt;/code&gt; lets us try out the new LED states.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum weatherState {
    WEATHER_STATE_BRING_UMBRELLA,
    WEATHER_STATE_CHANCE_OF_RAIN,
    WEATHER_STATE_NO_RAIN,
    WEATHER_STATE_CANT_CONNECT
};

// returns after 1 second
void controlWeatherLed(int state) {
    switch (state) {
        case WEATHER_STATE_BRING_UMBRELLA:
        digitalWrite(led1, HIGH);
        digitalWrite(led2, HIGH);
        delay(1000);
        break;

        case WEATHER_STATE_CHANCE_OF_RAIN:
        digitalWrite(led1, HIGH);
        digitalWrite(led2, HIGH);
        delay(200);

        digitalWrite(led1, LOW);
        digitalWrite(led2, LOW);
        delay(800);
        break;

        case WEATHER_STATE_NO_RAIN:
        digitalWrite(led1, LOW);
        digitalWrite(led2, LOW);
        delay(1000);
        break;

        case WEATHER_STATE_CANT_CONNECT:
        default:
        int i;
        for(i=0; i&amp;lt;5; i++) {
            digitalWrite(led1, HIGH);
            digitalWrite(led2, HIGH);
            delay(100);
            digitalWrite(led1, LOW);
            digitalWrite(led2, LOW);
            delay(100);
        }

        break;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Replace the code in &lt;code&gt;loop()&lt;/code&gt; with this snippet and loop will now cycle through the states, staying on each one for 5 seconds.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void loop() {
    controlWeatherLed(WEATHER_STATE_BRING_UMBRELLA);
    controlWeatherLed(WEATHER_STATE_BRING_UMBRELLA);
    controlWeatherLed(WEATHER_STATE_BRING_UMBRELLA);
    controlWeatherLed(WEATHER_STATE_BRING_UMBRELLA);
    controlWeatherLed(WEATHER_STATE_BRING_UMBRELLA);

    controlWeatherLed(WEATHER_STATE_CHANCE_OF_RAIN);
    controlWeatherLed(WEATHER_STATE_CHANCE_OF_RAIN);
    controlWeatherLed(WEATHER_STATE_CHANCE_OF_RAIN);
    controlWeatherLed(WEATHER_STATE_CHANCE_OF_RAIN);
    controlWeatherLed(WEATHER_STATE_CHANCE_OF_RAIN);

    controlWeatherLed(WEATHER_STATE_CANT_CONNECT);
    controlWeatherLed(WEATHER_STATE_CANT_CONNECT);
    controlWeatherLed(WEATHER_STATE_CANT_CONNECT);
    controlWeatherLed(WEATHER_STATE_CANT_CONNECT);
    controlWeatherLed(WEATHER_STATE_CANT_CONNECT);

    controlWeatherLed(WEATHER_STATE_NO_RAIN);
    controlWeatherLed(WEATHER_STATE_NO_RAIN);
    controlWeatherLed(WEATHER_STATE_NO_RAIN);
    controlWeatherLed(WEATHER_STATE_NO_RAIN);
    controlWeatherLed(WEATHER_STATE_NO_RAIN);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can get the full file here:&lt;/p&gt;

&lt;div id=&#34;gist300&#34;&gt;
&lt;style type=&#34;text/css&#34;&gt; 
#gist300 .gist .blob-wrapper.data {
   max-height:300px;
   overflow:auto;
}
&lt;/style&gt;
&lt;script src=&#34;https://gist.github.com/embedded-creations/4a2f94d155ecbfaf9586.js&#34;&gt; &lt;/script&gt;
&lt;/div&gt;

&lt;p&gt;Flash your Photon with the new program, and you&amp;rsquo;ll be able to see what the different states look like on the blue LED.&lt;/p&gt;

&lt;h3 id=&#34;webhooks-overview:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Webhooks Overview&lt;/h3&gt;

&lt;p&gt;Now we need to get data from a weather service.  Particle has an integration with IFTTT that looks really easy to set up, but I know from previous experience that IFTTT isn&amp;rsquo;t well suited to deliver this information.  You can set up a trigger on IFTTT to send the forecast at a specific time of day, but I want to see the latest forecast no matter when I look at the display, not just at one time during the day.  We&amp;rsquo;ll need to connect to a weather API and poll it periodically to keep the Photon updated with the latest forecast.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://forecast.io&#34;&gt;Forecast.io&lt;/a&gt; is my favorite website to check the weather, and I use their Dark Sky iOS app.  They have &lt;a href=&#34;https://developer.forecast.io&#34;&gt;an open API&lt;/a&gt;, and a Google search turned up a &lt;a href=&#34;https://medium.com/@dgmltn/particle-weather-widget-6f01eac5ec6c&#34;&gt;Photon project&lt;/a&gt; that gets data from the Forecast.io API using Webhooks.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.particle.io/guide/tools-and-features/Webhooks/&#34;&gt;Webhooks&lt;/a&gt; are an important feature of the Particle Cloud that allow a simple embedded device to get data from or send data to a web API that may be too complex to interact with directly.  Most microcontrollers aren&amp;rsquo;t powerful enough to connect directly over HTTPS, and the responses sent by most APIs are large and not easy to parse on a microcontroller.  Webhooks take care of those issues by querying the server from the cloud, and relaying the response back in a simple format.&lt;/p&gt;

&lt;p&gt;For example, a sample Forecast.io query I tried had over 23kB of data in the response that the Photon would have to store and parse through using complex code.  All I really want is a few values from that data with the chance of precipitation, and a Webhook can filter the rest out.&lt;/p&gt;

&lt;p&gt;Webhooks have been out of beta since March 2015, but unfortunately as of publishing this tutorial in February 2016, they have to be setup using the Particle CLI (command line interface), as there is not yet a web interface for creating and managing Webhooks.  You&amp;rsquo;ll need to &lt;a href=&#34;https://docs.particle.io/guide/tools-and-features/cli/photon/#installing&#34;&gt;follow the instructions&lt;/a&gt; in Particle Docs to install the CLI, which requires installing &lt;a href=&#34;https://nodejs.org/en/&#34;&gt;Node.js&lt;/a&gt; (I used v5.7.0 Stable).&lt;/p&gt;

&lt;p&gt;An important feature of Webhooks is responseTemplates, which give the option for the server to format the response so it contains just the data we are interested in, and to make the data easier to parse.  There&amp;rsquo;s only &lt;a href=&#34;https://docs.particle.io/guide/tools-and-features/webhooks/#responsetemplate&#34;&gt;minimal documentation&lt;/a&gt; on this feature, but I found helpful users on the forums posting what has worked for them, and &lt;a href=&#34;https://community.particle.io/t/tutorial-webhooks-and-responses-with-parsing-json-mustache-tokens/14612&#34;&gt;one user-submitted tutorial&lt;/a&gt;.  I&amp;rsquo;ll explain how to use responseTemplates later in this tutorial.&lt;/p&gt;

&lt;h3 id=&#34;getting-data-from-forecast-io:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Getting Data from Forecast.io&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s get started by signing up for a free &lt;a href=&#34;https://developer.forecast.io&#34;&gt;Forecast.io API account&lt;/a&gt;.   Once you&amp;rsquo;re in, copy your &lt;code&gt;APIKEY&lt;/code&gt; as you&amp;rsquo;ll need it later, and note that you shouldn&amp;rsquo;t share this with anyone, so don&amp;rsquo;t post it as part of a URL on a forum for example.  Next, go to the &lt;a href=&#34;https://developer.forecast.io/docs/v2&#34;&gt;API Docs&lt;/a&gt;, and scroll down to the first API call, &amp;ldquo;The Forecast Call&amp;rdquo;.  From the URL on the first line of this section, you can build up a call that returns the forecast.  First, substitute your APIKEY for the text &lt;code&gt;APIKEY&lt;/code&gt; in the URL.  Next, get your latitude and longitude.  An easy way to do this is by putting your address into the location box on the main &lt;a href=&#34;http://forecast.io&#34;&gt;Forecast.io homepage&lt;/a&gt; or by using the &amp;ldquo;Current Location&amp;rdquo; button on that page.  Your latitude and longitude are updated in your browsers URL, so copy those, and paste them into your API URL.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://api.forecast.io/forecast/APIKEY/LATITUDE,LONGITUDE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can paste your custom URL into a browser window and see what your Photon would receive using the simplest Webhook.  That&amp;rsquo;s a lot of data!  This data would come in 512 byte chunks, and it would be difficult to write code that is able to look for just the data we want across all those chunks.  That&amp;rsquo;s where responseTemplates come in.&lt;/p&gt;

&lt;p&gt;We need to tell the Webhook where to find the information we want, so lets figure that out ourselves.  First let&amp;rsquo;s make the JSON response easier to read.  Copy the whole response from your browser window, and paste it into the &amp;ldquo;text&amp;rdquo; window at &lt;a href=&#34;http://jsonviewer.stack.hu&#34;&gt;this online JSON viewer&lt;/a&gt;.  Press the &amp;ldquo;Format&amp;rdquo; button and it will add whitespace so you can see the structure easier.  Go to the &amp;ldquo;viewer&amp;rdquo; tab and you can see the data organized nicely.  You could go back to the API Docs and read up on what all these properties mean, but I found the names to be quite descriptive.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;DraggedImage-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m interested in if it might rain from the time I leave home, to when I might return.  I want this information at a glance, and we only have one LED, so I have to pick a single time range where I might be out.  I&amp;rsquo;m going to choose four hours as I work from home and would usually be going out for an errand or quick meetup.  With more LEDs, we could display several time ranges; that would be a good improvement for a future project.&lt;/p&gt;

&lt;p&gt;The &amp;ldquo;hourly&amp;rdquo; data block seems like the best choice for finding info on chance of rain in the next four hours.  We can look at &lt;code&gt;precipProbability&lt;/code&gt; in hourly data blocks 0-3.  Now to tell the Webhook to give us just this information.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;DraggedImage-4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;responsehooks-and-mustache-templates:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;ResponseHooks and Mustache Templates&lt;/h3&gt;

&lt;p&gt;The responseTemplate tells the Particle Cloud what data we want to receive, and the order and format we want to receive it in.  It only works with JSON formatted responses, not XML like many APIs still use.  It uses &lt;a href=&#34;http://mustache.github.io&#34;&gt;Mustache Templates&lt;/a&gt;, named for the curly braces that look like a bit like mustaches.  Let&amp;rsquo;s use the &lt;a href=&#34;http://mustache.github.io/#demo&#34;&gt;demo on the Mustache site&lt;/a&gt; to first explain how they work, then make a template for our data.&lt;/p&gt;

&lt;p&gt;The demo has three sections: Mustache (the template), JSON (the data to apply to the template), and HTML (the result of applying the JSON to the template).  In the demo, the Mustache template is a mix of HTML tags (in angle brackets &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;) and Mustache tags (in double curly braces &lt;code&gt;{{}}&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;The demo uses several features of Mustache templates, but the first line of the template is enough to demonstrate what we need for this project.  Press the &amp;ldquo;Render HTML&amp;rdquo; button, and you can see that &lt;code&gt;&amp;lt;h1&amp;gt;{{header}}&amp;lt;/h1&amp;gt;&lt;/code&gt; causes the value of &amp;ldquo;header&amp;rdquo; in the JSON object to show up in the HTML result between the &lt;code&gt;&amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt;&lt;/code&gt; tags.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;DraggedImage-5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;When we&amp;rsquo;re done putting our data in the demo boxes, &amp;ldquo;Mustache&amp;rdquo; is what we will use for the responseTemplate, &amp;ldquo;JSON&amp;rdquo; will be coming from Forecast.io, and the &amp;ldquo;HTML&amp;rdquo; section (which in our case doesn&amp;rsquo;t use HTML at all) is what we will send to the Photon.  Let&amp;rsquo;s come up with a template first.&lt;/p&gt;

&lt;p&gt;Going back to the JSON viewer, the data we want is the value of &lt;code&gt;precipProbability&lt;/code&gt; nested under &amp;ldquo;hourly&amp;rdquo;, &amp;ldquo;data&amp;rdquo;, and number 0-3.  We need four Mustarche tags in our template to render that data in the result.  Paste this into the &amp;ldquo;Mustache&amp;rdquo; section of the demo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{hourly.data.0.precipProbability}}
{{hourly.data.1.precipProbability}}
{{hourly.data.2.precipProbability}}
{{hourly.data.3.precipProbability}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can paste the Forecast.io JSON response for your custom API call into the demo&amp;rsquo;s JSON box.  Press the &amp;ldquo;Render Template&amp;rdquo; button and you should see four probability values show up in the HTML box.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;DraggedImage-6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In case there&amp;rsquo;s no rain in your forecast, try getting the forecast for somewhere that&amp;rsquo;s currently seeing some rain.  Drag the location pin on the &lt;a href=&#34;http://forecast.io&#34;&gt;Forecast.io&lt;/a&gt; weather globe to somewhere with some precipitation on the radar, make sure there&amp;rsquo;s rain in the forecast, then use the latitude/longitude from the browser URL to update your API URL.  Here&amp;rsquo;s a sample you can use:&lt;/p&gt;

&lt;div id=&#34;gist300&#34;&gt;
&lt;style type=&#34;text/css&#34;&gt; 
#gist300 .gist .blob-wrapper.data {
   max-height:300px;
   overflow:auto;
}
&lt;/style&gt;
&lt;script src=&#34;https://gist.github.com/embedded-creations/b3625d3a8eaa36b729ad.js&#34;&gt; &lt;/script&gt;
&lt;/div&gt;

&lt;p&gt;Now we need to make the response easy to parse.  The line breaks between values make it easy for us to read, but we could replace those with a token character to makes the response both readable and easily parseable by code.  Edit the template, deleting the line breaks and adding tilde &lt;code&gt;~&lt;/code&gt; characters between each Mustache tag:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{hourly.data.0.precipProbability}}~{{hourly.data.1.precipProbability}}~{{hourly.data.2.precipProbability}}~{{hourly.data.3.precipProbability}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now when you render, the result looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0.64~0.67~0.63~0.59
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;create-webhook:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Create Webhook&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;re now ready to build the Webhook.  Open a command prompt, and make sure Particle CLI is working by typing &lt;code&gt;particle&lt;/code&gt;.  You need to login to your Particle account the first time using the CLI, &lt;code&gt;particle login&lt;/code&gt;.  Run the &lt;code&gt;particle webhook create&lt;/code&gt; command without any more parameters in your terminal window, and it will return usage details including a JSON Template.  Copy the template and paste into a text editor, then save as &lt;code&gt;forecast_4hourrain.json&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Edit the template line by line:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;event&lt;/code&gt;- give it a good name, like &lt;code&gt;forecast_4hourrain&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;url&lt;/code&gt; - this is the API url with your APIKEY and location&lt;/li&gt;
&lt;li&gt;&lt;code&gt;deviceid&lt;/code&gt; - delete this line, we can use this Webhook with any of our devices&lt;/li&gt;
&lt;li&gt;You can delete the &amp;ldquo;following parameters are optional line&amp;rdquo;, it&amp;rsquo;s just a comment&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mydevices&lt;/code&gt; - set to &lt;code&gt;true&lt;/code&gt;, we don&amp;rsquo;t want someone else&amp;rsquo;s device accidentally using this Webhook and using up our limited API queries&lt;/li&gt;
&lt;li&gt;&lt;code&gt;requestType&lt;/code&gt; - set to &amp;ldquo;GET&amp;rdquo;, we are using an HTML GET for the query&lt;/li&gt;
&lt;li&gt;&lt;code&gt;form&lt;/code&gt; - delete, we&amp;rsquo;re not submitting a form&lt;/li&gt;
&lt;li&gt;&lt;code&gt;headers&lt;/code&gt; - delete, we don&amp;rsquo;t have custom headers&lt;/li&gt;
&lt;li&gt;&lt;code&gt;query&lt;/code&gt; - delete, we aren&amp;rsquo;t including extra parameters in the URL&lt;/li&gt;
&lt;li&gt;&lt;code&gt;json&lt;/code&gt; - delete, we&amp;rsquo;re not including JSON with the request&lt;/li&gt;
&lt;li&gt;&lt;code&gt;auth&lt;/code&gt; - delete, the API doesn&amp;rsquo;t use authentication&lt;/li&gt;
&lt;li&gt;&lt;code&gt;responseTemplate&lt;/code&gt; - paste the Mustache template in quotes replacing &lt;code&gt;null&lt;/code&gt;: &lt;code&gt;&amp;quot;{{hourly.data.0.precipProbability}}~{{hourly.data.1.precipProbability}}~{{hourly.data.2.precipProbability}}~{{hourly.data.3.precipProbability}}&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rejectUnauthorized&lt;/code&gt; - delete, only needed to ignore a bad SSL certification&lt;/li&gt;
&lt;li&gt;Make sure the last line (responseTemplate), doesn&amp;rsquo;t end with a comma, or the file won&amp;rsquo;t parse&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Your template should look like this, but containing your unique URL:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;event&amp;quot;: &amp;quot;forecast_4hourrain&amp;quot;,
  &amp;quot;url&amp;quot;: &amp;quot;https://api.forecast.io/forecast/APIKEY/40.7608,-73.9580&amp;quot;,
  &amp;quot;_&amp;quot;: &amp;quot;The following parameters are optional&amp;quot;,
  &amp;quot;mydevices&amp;quot;: &amp;quot;true&amp;quot;,
  &amp;quot;requestType&amp;quot;: &amp;quot;GET&amp;quot;,
  &amp;quot;responseTemplate&amp;quot;: &amp;quot;{{hourly.data.0.precipProbability}}~{{hourly.data.1.precipProbability}}~{{hourly.data.2.precipProbability}}~{{hourly.data.3.precipProbability}}&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can validate your JSON by pasting into &lt;a href=&#34;http://jsonlint.com/&#34;&gt;JSONLint&lt;/a&gt;; I initially had an extra comma after the &amp;ldquo;responseTemplate&amp;rdquo; line, and JSONLint caught it.  When you&amp;rsquo;re done, save, then use this command in a terminal window to create the Webhook on the Particle Cloud.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;particle webhook create forecast_4hourrain.json&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;You should see something like &amp;ldquo;&lt;code&gt;Successfully created webhook with ID ...&lt;/code&gt;&amp;rdquo;, and now we&amp;rsquo;re ready to update the firmware to read the Webhook.&lt;/p&gt;

&lt;h3 id=&#34;update-firmware-to-handle-webhook:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Update Firmware to Handle Webhook&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s easy to trigger the Webhook and have the Photon listen for a response.  Add this code in &lt;code&gt;setup()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if (Particle.subscribe(&amp;quot;hook-response/forecast_4hourrain&amp;quot;, gotForecast, MY_DEVICES)) {
        Serial.println(&amp;quot;subscribed!&amp;quot;);
    } else {
        Serial.println(&amp;quot;error: subscription failed&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add this function, which will be called when the Webhook response is received, and for right now, will print what it receives to a terminal over USB:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void gotForecast(const char *event, const char *data) {
    static int i = 0;
    i++;
    Serial.print(i);
    Serial.print(event);
    Serial.print(&amp;quot;, data: &amp;quot;);
    if (data)
        Serial.println(data);
    else
        Serial.println(&amp;quot;NULL&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, add this code to &lt;code&gt;loop()&lt;/code&gt; to trigger the Webhook:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    // wait 10 seconds after reset before sending the first trigger
    static unsigned long nextTrigger = 10 * 1000;

    if (nextTrigger &amp;lt; millis()) {
        // polling Webhook every 2 minutes is 720 API calls/day
        nextTrigger = millis() + 2*60*1000;

        Serial.println(&amp;quot;Requesting Forecast&amp;quot;);
        Particle.publish(&amp;quot;forecast_4hourrain&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s the full file with all the above changes:&lt;/p&gt;

&lt;div id=&#34;gist300&#34;&gt;
&lt;style type=&#34;text/css&#34;&gt; 
#gist300 .gist .blob-wrapper.data {
   max-height:300px;
   overflow:auto;
}
&lt;/style&gt;
&lt;script src=&#34;https://gist.github.com/embedded-creations/013642d5b7ff13ff2535.js&#34;&gt; &lt;/script&gt;
&lt;/div&gt;

&lt;p&gt;Before you flash your Photon with the new code, we need to get some debugging tools ready.  First, we need a tool for seeing USB Serial traffic from the Photon.  There are a lot of options, and you may already have a preferred serial terminal program.  If you don&amp;rsquo;t, Particle CLI - which we already installed - &lt;a href=&#34;https://github.com/spark/particle-cli#particle-serial-monitor&#34;&gt;includes a basic one&lt;/a&gt;.  Type this into your terminal window:&lt;br /&gt;
&lt;code&gt;particle serial monitor&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;You should see a response like &lt;code&gt;Opening serial monitor for com port: &amp;quot;/dev/cu.usbmodem1413521&amp;quot;&lt;/code&gt;, though it won&amp;rsquo;t actually open unless the Photon is running firmware that opens the Serial device.  You&amp;rsquo;ll need to run that command again each time the Photon resets, and the Photon will reset each time you flash it with new firmware.  This can get tiring if you are doing a lot of flashing, and there are programs out there that automatically reconnect after a disconnect (I personally use &lt;a href=&#34;https://www.decisivetactics.com/products/serial/&#34;&gt;Serial for the Mac&lt;/a&gt;), but the CLI serial monitor is good enough for this project.&lt;/p&gt;

&lt;p&gt;Next, it would be nice to have a way to see what&amp;rsquo;s going on in the Particle Cloud.  The &lt;a href=&#34;https://dashboard.particle.io/user/logs&#34;&gt;Particle Dashboard&lt;/a&gt; can show when the Cloud receives the publish event to start the Webhook, and Webhook request and response.&lt;/p&gt;

&lt;p&gt;OK, with all our dev tools ready, let&amp;rsquo;s flash the firmware.  Press the &amp;ldquo;flash&amp;rdquo; button in Particle Build, and watch your terminal window for the Photon to disconnect as it receives new firmware.  You can use the &lt;code&gt;particle serial monitor&lt;/code&gt; command immediately after it disconnects so the serial monitor is ready for the firmware to start.  Switch over to Particle Dashboard in your browser.&lt;/p&gt;

&lt;p&gt;If everything is working, you should see this in your serial monitor window:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Opening serial monitor for com port: &amp;quot;/dev/cu.usbmodem141331&amp;quot;
subscribed!
Requesting Forecast
1hook-response/forecast_4hourrain/0, data: 0~0~0~0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And you should see this in the Particle Dashboard:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;DraggedImage-7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Starting from the oldest message at the bottom, the first few messages are self explanatory, though you can ignore the &lt;code&gt;/spark/flash/status - failed&lt;/code&gt; event as I&amp;rsquo;ve never seen a &lt;code&gt;success&lt;/code&gt; event since starting with the Photon.   Next, the Photon published an event named &lt;code&gt;forecast_4hourrain&lt;/code&gt;, which triggers the Webhook request.  The next event, &lt;code&gt;hook-sent/forecast_4hourrain&lt;/code&gt; tells us that the Webhook was triggered and the Forecast.io Webhook was started.  We don&amp;rsquo;t subscribe to this event on the Photon, so nothing happens there, but if we did, we could print out a message for debugging.  The last event is &lt;code&gt;hook-response/forecast_4hourrain&lt;/code&gt;, which contains the data coming from Forecast.io after applying the responseTemplate.  We do subscribe to this event on the Photon, so it prints out &lt;code&gt;1hook-response/forecast_4hourrain/0, data: 0~0~0~0&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If you don&amp;rsquo;t see something similar, scroll down to the troubleshooting section at the end of the article, and make sure the Webhook is working properly before continuing on.&lt;/p&gt;

&lt;h3 id=&#34;control-led:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Control LED&lt;/h3&gt;

&lt;p&gt;OK, we have forecast data coming into the Photon, and a status LED, let&amp;rsquo;s get them working together.  We want &lt;code&gt;loop()&lt;/code&gt; to update the state of the display with the data from the forecast, then to call &lt;code&gt;controlWeatherLed()&lt;/code&gt; with the latest state.  Let&amp;rsquo;s start with the easy part, setting the state to     &lt;code&gt;WEATHER_STATE_BRING_UMBRELLA&lt;/code&gt; or &lt;code&gt;WEATHER_STATE_CHANCE_OF_RAIN&lt;/code&gt; based on the Webhook response.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll create a new variable called &lt;code&gt;state&lt;/code&gt;.  It needs to be declared outside of any function as it will be set by &lt;code&gt;gotForecast()&lt;/code&gt;, and used inside &lt;code&gt;loop()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// start off in WEATHER_STATE_CANT_CONNECT, this should update after the first Webhook response is received
int state = WEATHER_STATE_CANT_CONNECT;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In &lt;code&gt;gotForecast()&lt;/code&gt;, we should parse the Webhook response instead of just printing it.  The token characters we added between values in the response template are there so we can use the &lt;a href=&#34;http://www.cplusplus.com/reference/cstring/strtok/&#34;&gt;&lt;code&gt;strtok()&lt;/code&gt; (Split string into tokens) function&lt;/a&gt; to parse the response.  We want to know if there is a valid response from the API (are there any values?), if it&amp;rsquo;s going to rain (is probability is above the rain threshold?), or if there&amp;rsquo;s a chance it&amp;rsquo;s going to rain (is probability is below the rain threshold but above the chance threshold?).  Add this to the end of &lt;code&gt;gotForecast()&lt;/code&gt; to parse the response, looking for the largest probability value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    // strtok can&#39;t work with const data array, copy to editable array - length is 4x prob values (4*4 chars), three tokens + null
    char dataString[4 * 4 + 3 + 1];
    strncpy(dataString, data, sizeof(dataString));

    // go through array, parse each probability value and find the largest
    i = 0;
    float largestProbability = -1.0;
    char * pch = strtok(dataString, &amp;quot;~&amp;quot;);
    while (pch != NULL) {
        float probability = atof(pch);

        Serial.print(&amp;quot;Chance of rain in hour &amp;quot;);
        Serial.print(i);
        Serial.print(&amp;quot;: &amp;quot;);
        Serial.println(probability);

        if (probability &amp;gt; largestProbability)
            largestProbability = probability;

        pch = strtok(NULL, &amp;quot;~&amp;quot;);
        i++;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have the largest probability value from the response, it&amp;rsquo;s easy to set the state.  First we need to define the thresholds (you can easily change these to your liking):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const float umbrellaThreshold = 0.50;
const float chanceofrainThreshold = 0.25;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, at the end of &lt;code&gt;gotForecast()&lt;/code&gt; we compare the thresholds to the largest probability:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if (largestProbability &amp;lt; 0) {
        state = WEATHER_STATE_CANT_CONNECT;
        Serial.println(&amp;quot;Response didn&#39;t contain valid data - WEATHER_STATE_CANT_CONNECT&amp;quot;);
    } else if (largestProbability &amp;gt;= umbrellaThreshold) {
        state = WEATHER_STATE_BRING_UMBRELLA;
        Serial.println(&amp;quot;Bring an umbrella! - WEATHER_STATE_BRING_UMBRELLA&amp;quot;);
    } else if (largestProbability &amp;gt;= chanceofrainThreshold) {
        state = WEATHER_STATE_CHANCE_OF_RAIN;
        Serial.println(&amp;quot;It might rain! - WEATHER_STATE_CHANCE_OF_RAIN&amp;quot;);
    } else {
        state = WEATHER_STATE_NO_RAIN;
        Serial.println(&amp;quot;Doesn&#39;t look like rain - WEATHER_STATE_NO_RAIN&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Going back to &lt;code&gt;loop()&lt;/code&gt;, we can replace our demo calls to &lt;code&gt;controlWeatherLed()&lt;/code&gt; with one real call using the state variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    controlWeatherLed(state);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s the full file with all the above changes:&lt;/p&gt;

&lt;div id=&#34;gist300&#34;&gt;
&lt;style type=&#34;text/css&#34;&gt; 
#gist300 .gist .blob-wrapper.data {
   max-height:300px;
   overflow:auto;
}
&lt;/style&gt;
&lt;script src=&#34;https://gist.github.com/embedded-creations/64d9e663bc9bfaba480f.js&#34;&gt; &lt;/script&gt;
&lt;/div&gt;

&lt;p&gt;Flash your Photon, and after receiving the response, it should print out the chance of rain for the next four hours and the state over Serial, and drive the blue LED accordingly.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;subscribed!
Requesting Forecast
1hook-response/forecast_4hourrain/0, data: 0~0~0~0
Chance of rain in hour 0: 0.00
Chance of rain in hour 1: 0.00
Chance of rain in hour 2: 0.00
Chance of rain in hour 3: 0.00
Doesn&#39;t look like rain - WEATHER_STATE_NO_RAIN
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;robustness:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Robustness&lt;/h3&gt;

&lt;p&gt;So, we have a LED that tells us the chance of rain, updating every two minutes, and will tell us if there&amp;rsquo;s a problem, right?  Not quite.  The state only updates if we get a response from the Webhook, and with a connectivity problem or Webhook problem, we may never get a response.  Let&amp;rsquo;s set a timeout after making the Webhook request, and make sure there&amp;rsquo;s a response received before the timeout.&lt;/p&gt;

&lt;p&gt;We create a new global timeout variable, as it needs to be accessed by both &lt;code&gt;loop()&lt;/code&gt; and &lt;code&gt;gotForecast()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// keep track of when we expect a response from the Webhook
unsigned long nextTimeout;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Set the timeout in &lt;code&gt;loop()&lt;/code&gt; right after publishing the Webhook request:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        // We expect a response within 30 seconds
        nextTimeout = millis() + 30 * 1000;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Look for an expired timeout in &lt;code&gt;loop()&lt;/code&gt;, right before calling &lt;code&gt;controlWeatherLed()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if (nextTimeout &amp;lt; millis()) {
        // we waited too long for a response, set to error state and set timeout to far off future
        state = WEATHER_STATE_CANT_CONNECT;
        nextTimeout = ULONG_MAX;
        Serial.println(&amp;quot;Response timeout - WEATHER_STATE_CANT_CONNECT&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally, disable the timeout when we get a Webhook response in &lt;code&gt;gotForecast()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    // we got our response, set timeout to the far off future
    nextTimeout = ULONG_MAX;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now our program is complete.  Flash your Photon with the final code:&lt;/p&gt;

&lt;div id=&#34;gist300&#34;&gt;
&lt;style type=&#34;text/css&#34;&gt; 
#gist300 .gist .blob-wrapper.data {
   max-height:300px;
   overflow:auto;
}
&lt;/style&gt;
&lt;script src=&#34;https://gist.github.com/embedded-creations/d9618fe08c9000744f3f.js&#34;&gt; &lt;/script&gt;
&lt;/div&gt;

&lt;h2 id=&#34;testing:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Testing&lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;re done, right?  Let&amp;rsquo;s find out by doing some quick tests.  It&amp;rsquo;s not easy to test with realtime data for your location as the weather doesn&amp;rsquo;t usually change that quickly and we&amp;rsquo;re looking at a four-hour window. Instead, let&amp;rsquo;s change the Webhook.&lt;/p&gt;

&lt;p&gt;An easy test is to see what happens when the Webhook call fails.  Delete the Webhook using these commands:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;particle webhook list&lt;/code&gt; - use to get the Hook ID of &lt;code&gt;forecast_4hourrain&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;particle webhook delete HOOKID&lt;/code&gt; - replace &lt;code&gt;HOOKID&lt;/code&gt; with your actual 24-digit ID&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now, wait the two minutes for the next Webhook request plus 30 seconds for the timeout, and you should see the state change to &lt;code&gt;WEATHER_STATE_CANT_CONNECT&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;While you&amp;rsquo;re waiting, make three copies of your &lt;code&gt;forecast_4hourrain.json&lt;/code&gt; file, call them &lt;code&gt;forecast_4hourrain_umbrella.json&lt;/code&gt;, &lt;code&gt;forecast_4hourrain_chancerain.json&lt;/code&gt;, &lt;code&gt;forecast_4hourrain_norain.json&lt;/code&gt;.  Go to &lt;a href=&#34;http://forecast.io&#34;&gt;forecast.io&lt;/a&gt; and move the pin around on the globe to find areas that are currently raining, have a chance of rain, and have no rain in the next four hours.  One of these is redundant as your home already falls into one of these categories.  For each that you still need to test, create an API URL for the location, verify the precipitationProbability for the next 4 hours using your browser to do the request and &lt;a href=&#34;http://jsonviewer.stack.hu&#34;&gt;jsonviewer&lt;/a&gt; to view the data, and paste the API URL into your JSON file.  It can be difficult to find a location with just a chance of rain, it took me about ten tries looking at the API response for locations that looked promising on the map (zoomed in to the Regional level and on the edges of storms) before finding a location that had a chance of precipitation, but was &amp;lt; 50%.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s finish up the &lt;code&gt;WEATHER_STATE_CANT_CONNECT&lt;/code&gt; test, did you see the state change in both the terminal and see a fast flashing LED?  Great!&lt;/p&gt;

&lt;p&gt;To test the other conditions, one by one, delete the previous Webhook (&lt;code&gt;particle webhook list&lt;/code&gt; to get the &lt;code&gt;HOOK_ID&lt;/code&gt;, then &lt;code&gt;particle webhook delete HOOK_ID&lt;/code&gt;), create the new one using your modified JSON file (&lt;code&gt;particle webhook create FILENAME.json&lt;/code&gt;), and wait to see the results on your Photon.  It&amp;rsquo;s going to be faster to reset your Photon each time and wait ten seconds for the request than to wait up to two minutes for the firmware to request on its normal schedule.  Finally, delete the test Webhook and load the normal Webhook for your location.&lt;/p&gt;

&lt;p&gt;Did you see the LED turn on for the location with rain, LED showing a short pulse for the location with a chance of rain, and LED turn off for the location with no rain?  Great, now we&amp;rsquo;re confident that everything is working properly, and you can start using your new umbrella reminder display!&lt;/p&gt;

&lt;h2 id=&#34;next-steps:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Next Steps&lt;/h2&gt;

&lt;h3 id=&#34;customizing-the-data:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Customizing the Data&lt;/h3&gt;

&lt;p&gt;Maybe you have different thresholds for when you want to see &amp;ldquo;chance&amp;rdquo; of rain, or you want to change the display to show the next eight hours.  You should be able to easily modify the code and Webhook to show you what you want to see.&lt;/p&gt;

&lt;p&gt;Maybe you&amp;rsquo;re more interested in seeing the current or forecasted temperature?  There&amp;rsquo;s a lot more data in the Forecast.io API response that could be used instead.&lt;/p&gt;

&lt;h3 id=&#34;mounting-and-enclosures:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Mounting and Enclosures&lt;/h3&gt;

&lt;p&gt;You can mount the Photon where you want to see the information, maybe near the front door, where you keep your umbrella, where you get dressed in the morning, or anywhere else you&amp;rsquo;re likely to glance at when you&amp;rsquo;re getting ready to go out.&lt;/p&gt;

&lt;p&gt;The little matchbox case the Photon comes in can be used for a makeshift enclosure as the LEDs shine through the translucent material.  It&amp;rsquo;s flexible enough to allow the USB cable to remain attached for power.  With a little cutout in the cardboard made with a hobby knife, it fits even better.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;DraggedImage-8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Maybe the Photon enclosure is a little too rough, you could make your own.  A picture frame with thin white paper or a translucent material could be a good start.&lt;/p&gt;

&lt;h3 id=&#34;customizing-the-electronics:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Customizing the Electronics&lt;/h3&gt;

&lt;p&gt;Is the built-in LED not bright enough, or do you want to display more information?  It&amp;rsquo;s easy to add a brighter external LED, the code already drives pin D0 like in the Photon &lt;a href=&#34;https://docs.particle.io/guide/getting-started/examples/photon/#blink-an-led&#34;&gt;Blink an LED&lt;/a&gt; example.  You could use a &lt;a href=&#34;https://www.adafruit.com/products/2268&#34;&gt;NeoPixel Ring Kit&lt;/a&gt; (requires a bit of easy soldering), or the &lt;a href=&#34;https://www.particle.io/button&#34;&gt;Internet Button&lt;/a&gt; to add more LEDs, and modify the firmware to drive the ring instead of just the onboard LED.  With a ring, you could display the chance of rain for each hour separately, or other information.&lt;/p&gt;

&lt;h1 id=&#34;troubleshooting:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Troubleshooting&lt;/h1&gt;

&lt;p&gt;Are you seeing &lt;code&gt;&amp;quot;~~~&amp;quot;&lt;/code&gt; with no values instead of &lt;code&gt;&amp;quot;0~0~0~0&amp;quot;&lt;/code&gt;?  The Webhook subscription failed, double check the info in your Webhook .json file, specifically the API URL in your Webhook.  Make sure you can&lt;/p&gt;

&lt;p&gt;Having other issues?  &lt;a href=&#34;mailto:hello@connected-displays.com&#34;&gt;Let us know&lt;/a&gt;, or post a question on the &lt;a href=&#34;http://community.particle.io&#34;&gt;Particle Community&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;conclusion:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;This tutorial gave you an overview of how to get started with the Photon, poll for information from an API, and display it locally.  If you followed along, maybe you built your first connected display project!  I hope it gave you some good experience and confidence to do another project, or make your own!&lt;/p&gt;

&lt;p&gt;Make sure to subscribe to our email list to find out when our next tutorial is posted.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ESP8266 Weather Display</title>
      <link>http://www.connected-displays.com/post/esp8266-weather-display/</link>
      <pubDate>Mon, 04 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://www.connected-displays.com/post/esp8266-weather-display/</guid>
      <description>

&lt;p&gt;I came across a tutorial in the Adafruit Learning System about a &lt;a href=&#34;https://learn.adafruit.com/huzzah-weather-display/&#34;&gt;WiFi-connected Weather Display&lt;/a&gt; that caught my eye.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;adafruit-weather-display.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The tutorial shows how to use Huzzah - Adafruit’s breakout for the ESP8266 WiFi module - to display weather data on an OLED screen.  The project is listed as an intermediate level project, because it requires a PHP script to be running on a separate computer or Raspberry Pi to translate data from a weather forecast API to a format the microcontroller can handle.&lt;/p&gt;

&lt;p&gt;When I looked into the details, I found the tutorial on Adafruit was based on &lt;a href=&#34;http://blog.squix.ch/2015/06/esp8266-weather-station-v2-code.html&#34;&gt;another project&lt;/a&gt; by Dani Eichhorn; I’ll talk about both projects here.&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/cNmsZvzq-Vg&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;h2 id=&#34;hardware:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Hardware&lt;/h2&gt;

&lt;p&gt;The core hardware of the project is simple: an ESP8266 breakout board, monochrome 1.3&amp;rdquo; 128x64 SSD1306 OLED display with I2C connection, some jumper wires and a connection to external power over USB.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;http://blog.squix.ch/2015/06/esp8266-weather-station-v2-code.html&#34;&gt;original project&lt;/a&gt; uses a NodeMCU board.  The board has not only an ESP8266 chip but also a microUSB jack and USB-Serial converter chip so you can program the chip directly over USB and power the project through USB.  The parts Dani used come with pins already soldered, ready to connect with jumper wires.  This makes for a much easier to assemble project, but there will be a mess of wires behind the OLED display that can&amp;rsquo;t be contained in a small enclosure.  The author is selling the parts you need for the project &lt;a href=&#34;http://blog.squix.ch/p/weatherstation-kit.html&#34;&gt;as a reasonably priced kit&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The Adafruit tutorial adds a few more parts - required as their Huzzah ESP8266 breakout doesn&amp;rsquo;t have a USB port for programming or power - and their tutorial requires soldering all the parts together.  On the plus side, the soldering leaves the assembled project in a more compact form.  The tutorial includes a design for a case to hold everything if you want to source the laser cut acrylic and fasteners yourself.&lt;/p&gt;

&lt;h2 id=&#34;software:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Software&lt;/h2&gt;

&lt;p&gt;The Arduino code is well written and easy to understand.  There are three screens that cycle between the current weather, current temperature, and tomorrows forecast, and are populated with a combination of text and an icon.  The icons are mono-color bitmaps converted to &lt;a href=&#34;https://en.wikipedia.org/wiki/X_BitMap&#34;&gt;XBM (X Bitmap) format&lt;/a&gt; which uses 1 bit per pixel, and is stored as an array for easily including with the source code.&lt;/p&gt;

&lt;p&gt;The display is driven over I2C with a custom OLED driver class that is specifically designed to scroll through several frames of information.  The class doesn’t do temporary storage of any frames, they are written to the display directly.  During frame transitions, the graphics for the previous and next frames are generated and written out to the display at each step in the transition animation.  This is a clever way to save memory while seamlessly transitioning between the frames.&lt;/p&gt;

&lt;p&gt;The PHP script is used to convert the weather data to a format that is easier to store and parse on the ESP8266.  When requested by an HTTP GET request from the microcontroller, the script requests a JSON object containing the weather from the &lt;a href=&#34;https://developer.forecast.io&#34;&gt;forecast.io&lt;/a&gt; API, then responds to the micocontroller with  just the necessary values as key-value pairs that are easy for the microcontroller to parse.&lt;/p&gt;

&lt;h2 id=&#34;what-s-unique-about-this-project:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;What’s unique about this project?&lt;/h2&gt;

&lt;p&gt;This isn&amp;rsquo;t the first ESP8266 weather display out there, but it&amp;rsquo;s the first I&amp;rsquo;ve seen that adds nice graphics to the display including transitions between frames, and does it all with the ESP8266 module, and not a separate Arduino or similar microcontroller.&lt;/p&gt;

&lt;p&gt;The Adafruit version builds on the original project with an enclosure and compact layout, and well documented tutorial that shows how to put everything together.&lt;/p&gt;

&lt;h2 id=&#34;suggestions-for-the-next-version:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Suggestions for the Next Version&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;d like to see animated weather icons, like the ones used by the &lt;a href=&#34;http://forecast.io/&#34;&gt;forecast.io weather service&lt;/a&gt; on their site.  The I2C connection to the display may be too slow for smooth animation, but there are plenty of pins on both the Node MCU and Huzzah modules to switch to a faster SPI connection which &lt;a href=&#34;https://www.youtube.com/watch?v=SvOX-xs9v8M&#34;&gt;can update fast enough for smooth animation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It would also be nice to figure out a way to make installing the PHP script unnecessary or easy for a beginner, to make the project easier to replicate.  If the ESP8266 can’t handle parsing data from the weather API directly, maybe the tutorial could explain how to install the PHP script for someone that&amp;rsquo;s not familiar with running PHP scripts.&lt;/p&gt;

&lt;p&gt;The Adafruit version requires more parts and tools as their Huzzah WiFi module doesn&amp;rsquo;t include a USB connection for programming or powering the module.  I have to imagine they are working on a more full-featured product to compete with the NodeMCU and similar ESP8266 modules, and it would be nice to see their tutorial updated to use the new module if one becomes available.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Smart Stickers Product Preview</title>
      <link>http://www.connected-displays.com/post/smart-stickers-product-preview/</link>
      <pubDate>Thu, 10 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>http://www.connected-displays.com/post/smart-stickers-product-preview/</guid>
      <description>

&lt;p&gt;There’s an &lt;a href=&#34;https://www.indiegogo.com/projects/smart-sticker-customizable-real-time-display#/story&#34;&gt;Indiegogo campaign&lt;/a&gt; running for Smart Stickers - low cost bluetooth connected E-ink displays.  The product looks interesting, and I want this to become a real product, but I have some serious doubts about the campaign.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.indiegogo.com/projects/smart-sticker-customizable-real-time-display#/story&#34;&gt;&lt;img src=&#34;overview.jpg&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;tech:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Tech&lt;/h2&gt;

&lt;h3 id=&#34;e-ink-display:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;E-Ink Display&lt;/h3&gt;

&lt;p&gt;Smart Stickers use a 2.7” Pervasive Displays E-Ink screen.  These screens are capable of displaying black and white only, and are 264x176 pixels.  The screens only consume power when refreshing, and so are well suited to displaying information that refreshes infrequently when powered by a battery.  The screens are not nearly as fast to update as the LCD displays on a smartphone, and to avoid ghosting, must go through a sequence of intermediate images when refreshing, drawing the inverse of the previous image and the inverse of the new image before drawing the new image.  This can take some time and looks unpleasant.  In the example screens shown in the video with the current time, the screen must be refreshed every minute to update the time.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;epaperrefresh.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;source: &lt;a href=&#34;http://repaper.org/doc/cog_driving.html#data-structure&#34;&gt;repaper.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This isn’t displayed in the Smart Stickers video, but there is an &lt;a href=&#34;https://youtu.be/c_j6QWyRJLg?t=1m53s&#34;&gt;example on Youtube&lt;/a&gt; of an Embedded Artists development board refreshing a 2.7” Pervasive Displays E-Ink screen.&lt;/p&gt;

&lt;p&gt;The Pervasive E-Ink displays are &lt;a href=&#34;https://www.adafruit.com/products/1346&#34;&gt;readily available for prototyping&lt;/a&gt;, with example code for Arduino and other platforms.&lt;/p&gt;

&lt;h3 id=&#34;bluetooth-low-energy:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Bluetooth Low Energy&lt;/h3&gt;

&lt;p&gt;Smart Stickers use a Bluetooth Low Energy (BLE) module for connecting to a smartphone to configure the display and update information.  The outline in the mechanical drawing looks like a &lt;a href=&#34;http://www.aliexpress.com/wholesale?catId=0&amp;amp;SearchText=hm-11&#34;&gt;HM-11 module&lt;/a&gt;.  BLE is a good choice for being able to use minimal power but still be accessible for immediate updates as new information arrives.  It has some drawbacks however, as it requires a smartphone to connect to the internet.  You couldn’t set the display up for your family, for example, and expect it to update while you and your phone were away from home.  BLE has a low data rate, &lt;a href=&#34;https://atmosphere.anaren.com/wiki/Data_rates_using_BLE&#34;&gt;roughly 10kB/s max&lt;/a&gt;, but this shouldn’t be a problem as a 264x176 mono image is less than 6kB, so the phone could push an entire image in less than a second.&lt;/p&gt;

&lt;h4 id=&#34;why-not-wifi:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Why not WiFi?&lt;/h4&gt;

&lt;p&gt;Smart Stickers are similar in concept to &lt;a href=&#34;https://www.kickstarter.com/projects/914874115/displio-wifi-display-that-tracks-whats-important-t&#34;&gt;DISPLIO&lt;/a&gt;, a WiFi connected E-ink display that was also crowdfunded this year.  There are a couple reasons why Smart Stickers may have picked BLE over WiFi.  The first is power consumption.  BLE can stay in a low power mode where it is listening for new messages from the smartphone but using very little power, where WiFi uses a lot more power when it is active.  Smart Stickers can get updates in close to real time, while with DISPLIO, you have to choose between frequent updates or long battery life, and there is no option for always listening on battery power.  A second reason might be cost: BLE chipsets are generally cheaper than WiFi, though with chips like the ESP8266, that is starting to change.  A third reason might be reduced complexity: with BLE there’s no need to program WiFi credentials into the display or troubleshoot network issues, and the firmware only needs to communicate with the smartphone app, not a server in the cloud.&lt;/p&gt;

&lt;h3 id=&#34;software:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Software&lt;/h3&gt;

&lt;p&gt;There is no mention of a microcontroller on the Smart Stickers description except for the CC2541 BLE chipset.  The CC2541 has an 8051 core with 128/256kB flash and 8kB RAM, so it seems capable of updating the panel in addition to handling BLE communication.  The design will need more memory to store the image as the E-Ink display is write only, and requires an entire row to be refreshed even when updating a single pixel.  I didn’t see any external memory in the published Smart Stickers CAD drawings, but they may not be up to date.&lt;/p&gt;

&lt;p&gt;In the simplest design, most of the intelligence can stay in the smartphone app, and the display firmware can be limited to updating the display with a new image sent by the smartphone.  This makes sense for a lot of content, as weather or social media notifications can’t be updated without data from the smartphone.  Other content - like the current time - could update on its own without wasting battery by communicating over BLE.  The display could also store fonts and icons so an image could be built up without sending bitmap data over BLE with every update.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;app.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The Smart Stickers App lets you customize your screen, dividing the screen up into 15 segments, with widgets taking up one or more segments.  This seems like a smart way to allow for flexibility while still keeping the design simple.&lt;/p&gt;

&lt;h3 id=&#34;concerns:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Concerns&lt;/h3&gt;

&lt;p&gt;While I like the design of this product, it’s good to be a bit skeptical when backing projects on crowdfunding sites, as there is no guarantee that the company will be able to deliver the product.&lt;/p&gt;

&lt;p&gt;I saw a couple red flags immediately when looking at this campaign.  First, it is a “&lt;a href=&#34;https://support.indiegogo.com/hc/en-us/articles/205138007-Choose-Your-Funding-Type-Can-I-Keep-My-Money-&#34;&gt;flexible funding&lt;/a&gt;” campaign, which means that even if Smart Stickers doesn’t reach it’s $75,000 goal, they keep all the funds anyway.  This could put them in a dangerous position where they have a commitment to build product for their customers, but not enough money raised to actually do it.  Too many crowdfunding campaigns have ended with the project creator losing money on the campaign and still unable to deliver products to their backers.&lt;/p&gt;

&lt;p&gt;Second, the price is really low - especially at the early bird levels - but $30 including shipping seems too low for a product like this.  The E-Ink display itself is $15 &lt;a href=&#34;%5Bhttp://www.digikey.com/product-detail/en/E1271CS021/E1271CS021-ND/5046793%5D&#34;&gt;from Digi-Key&lt;/a&gt; in 100 piece quantities, though they may be able to get a lower price with volume or by sourcing direct from Pervasive Displays.  Even so, adding up the costs of display, BLE module, battery, custom circuit board, enclosure, assembly, and worldwide shipping, then considering the up-front costs for tooling needed for an enclosure, and margin to make some profit - this seems too cheap.&lt;/p&gt;

&lt;p&gt;Next, the schedule doesn’t seem realistic.  They’re supposed to be sourcing parts in December, but won’t know the number of units to build until the campaign ends at the end of December.  It seems unlikely that they will be able to do a production run in January with such a short time to source parts.  Shipping isn’t until February, but February is also Chinese New Year, which puts a major delay into production and shipping schedules &lt;a href=&#34;http://www.ewmfg.com/chinese-new-year/&#34;&gt;before and after the holiday&lt;/a&gt;.  There are FCC and CE logos on the packaging, but no accounting for the time it takes to test, and possibly modify the design if tests fail.&lt;/p&gt;

&lt;p&gt;Finally, there are no live shots of the prototypes updating the display.  The same image is on the display in almost all the real life photos, with one exception.  It would be easy to use a development board to draw a mockup image to an E-Ink panel, put the panel in an enclosure, without actually building a functioning prototype.  It would be even easier to print out a photo of the screen content and put that in an enclosure.  The video and photos don’t give me confidence that there is a working prototype of the product.&lt;/p&gt;

&lt;p&gt;Many of the renderings on the campaign page don’t show the pixelation that E-Ink displays will have - especially in the circles and fonts with fine lines.  With the display limited to black and white, it’s not capable of anti-aliasing and the edges of fine lines will look jagged.  Here’s &lt;a href=&#34;https://developer.mbed.org/users/dreschpe/code/EaEpaper/&#34;&gt;this example&lt;/a&gt; of what fonts and circles look like on the actual E-Ink display to the Smart Stickers rendering:
&lt;img src=&#34;epaperdrawing.jpg&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;smartstickerrender.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;summary:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;I like the concept of this product and I hope to see it get to market.  I see too many red flags with this campaign to recommend backing it.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.e-ink-info.com/smart-stickers-want-raise-75000-make-30-e-ink-devices&#34;&gt;via E-Ink Info&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MoodLight Product Preview</title>
      <link>http://www.connected-displays.com/post/moodlight-product-preview/</link>
      <pubDate>Fri, 04 Dec 2015 12:22:39 -0500</pubDate>
      
      <guid>http://www.connected-displays.com/post/moodlight-product-preview/</guid>
      <description>

&lt;p&gt;Connor Nishijima created an online service that monitors Twitter for people expressing their emotions, and is in the middle of a &lt;a href=&#34;https://www.kickstarter.com/projects/connornishijima/moodlight-a-wifi-enabled-window-to-the-worlds-emot&#34;&gt;Kickstarter campaign&lt;/a&gt; to show that data on a WiFi connected display.&lt;/p&gt;

&lt;iframe width=&#34;640&#34; height=&#34;480&#34; src=&#34;https://www.kickstarter.com/projects/connornishijima/moodlight-a-wifi-enabled-window-to-the-worlds-emot/widget/video.html&#34; frameborder=&#34;0&#34; scrolling=&#34;no&#34;&gt; &lt;/iframe&gt;

&lt;p&gt;The twitter data is analyzed by a server, and you can see it working on the &lt;a href=&#34;http://moodlighting.co/stats/&#34;&gt;MoodLighting Stats page&lt;/a&gt;.  The display polls the server for new data every second, and lights up nine LEDs to display the current state of emotions.  The light appears to fade between different shades as emotions gradually change, but also can flash to get your attention if a sudden change in emotions is detected.&lt;/p&gt;

&lt;h2 id=&#34;hardware:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Hardware&lt;/h2&gt;

&lt;p&gt;The project uses the popular ESP8266 module for connecting to WiFi, but most of the code is running on an ATmega328P, the same chip that&amp;rsquo;s on an Arduino Uno.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;hardware.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The electronics are enclosed in a laser cut birch veneer enclosure, with options to buy the display fully assembled, or as a cheaper unassembled version that you can glue together yourself.  The LEDs are diffused through a sheet of what looks like frosted acrylic, that creates a blending effect for the LEDs, which is more pleasant to look at than bare LEDs and is well suited for a display showing ambient information.&lt;/p&gt;

&lt;h2 id=&#34;software:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Software&lt;/h2&gt;

&lt;p&gt;Most of the intelligence is in the cloud, keeping the firmware simple so it doesn&amp;rsquo;t need to be changed if Twitter updates its API, or MoodLighting improves its mood data analysis.&lt;/p&gt;

&lt;h2 id=&#34;likes:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Likes&lt;/h2&gt;

&lt;p&gt;I like that the project leverages code on an online server to do the heavy lifting of analyzing data, which simplifies the firmware running on the display and reduces data usage.&lt;/p&gt;

&lt;p&gt;The diffused LEDs are good choice for representing data without being distracting, but the display also implements a flashing mode to grab attention when needed.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;isoview.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The project is open source - the firmware, PCB design, and mechanical details for the enclosure are posted on GitHub as of the start of the campaign - though it&amp;rsquo;s unclear what license the code and drawings are shared with.&lt;/p&gt;

&lt;p&gt;Connor has thought about alternate uses for the display beyond displaying mood data.  You can program it yourself with user-friendly &lt;a href=&#34;http://ifttt.com&#34;&gt;IFTTT&lt;/a&gt;, or you can bypass the cloud completely by using local UDP messages.&lt;/p&gt;

&lt;h2 id=&#34;concerns:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Concerns&lt;/h2&gt;

&lt;p&gt;The project&amp;rsquo;s funding goals are very low, and the product doesn&amp;rsquo;t seem heavily marked up, which means there isn&amp;rsquo;t a lot of money left over after fulfilling the Kickstarter rewards.  One of the stretch goals that has already been met is to create a cross-platform app for the display, which could be a significant expense.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s not clear if there is a plan to be able to update the firmware either remotely or over USB, even after I looked at the firmware for both the main microcontroller and the wifi module.  It appears that other than the advanced use of sending local packets over UDP, data for the display need to come through the &amp;ldquo;www.moodlighting.co&amp;rdquo; server, so the functionality of the device depends on the server being maintained.&lt;/p&gt;

&lt;h2 id=&#34;suggestions-for-the-next-version:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Suggestions for the Next Version&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;d like to see an option to customize the feeds that are monitored for mood, to show only twitter accounts you&amp;rsquo;re following for example.  If that&amp;rsquo;s too complicated, maybe there could be an option to show only certain groups on twitter, e.g. by region, language, or type of twitter user.&lt;/p&gt;

&lt;p&gt;For users that just want an ambient information display, and not notifications, an option to turn off the flashing notification would be nice.&lt;/p&gt;

&lt;p&gt;The LED fading looks pretty good in the video, but I&amp;rsquo;d love to see what it could look like if it were using &lt;a href=&#34;http://fastled.io&#34;&gt;FastLED&lt;/a&gt; and some of the code shared in &lt;a href=&#34;http://fastled.io/+&#34;&gt;their community&lt;/a&gt; instead of the basic Adafruit NeoPixel library.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://hackaday.com/2015/10/12/internet-connected-box-displays-emotion-basement-dwellers-still-unaffected&#34;&gt;via Hackaday&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lametric Time - Initial Review</title>
      <link>http://www.connected-displays.com/post/lametric-time-initial-review/</link>
      <pubDate>Sun, 15 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>http://www.connected-displays.com/post/lametric-time-initial-review/</guid>
      <description>

&lt;p&gt;I was excited to learn about the LaMetric Time when it launched on Kickstarter in July 2014.  I was lucky enough to be an early backer at the $119 price for a plug-in LaMetric (no battery), and I just opened it up and spent about an hour playing with it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;timebanner.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;LaMetric Time was interesting to me because of its pixelated LED display and potential for customization, displaying any data that&amp;rsquo;s available from the web.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s my initial thoughts, though I will be writing about this display later as I customize it for my needs and start using it regularly.&lt;/p&gt;

&lt;h2 id=&#34;hardware:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Hardware&lt;/h2&gt;

&lt;p&gt;The Time has attractive industrial design.  The display has a nice matte black textured finish that resists fingerprints, but does seem to collect dust, and rounded corners on the vertical edges.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;LaMetric%20-%20big%20buttons.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The front of the display hides the LEDs perfectly when off.  You can&amp;rsquo;t tell that it&amp;rsquo;s a display at all.  When on, the LEDs are separated into square pixels with thin borders between each pixel.  The diffusion within each square is pretty good, though you can see it&amp;rsquo;s brighter at the center than the edges instead of ideally even brightness across the square.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s not a lot you can do with 8x8 graphics, though it&amp;rsquo;s pretty easy to tell what the icons represent.  The animations are very simple, and I haven&amp;rsquo;t yet dug in to figure out if that&amp;rsquo;s a limitation of the number of frames, color palette available, a stylistic choice, or just because it&amp;rsquo;s harder to make a more complicated animation.  It&amp;rsquo;s unfortunate that only the left 8x8 side on the display is RGB, and the rest is only capable of display of displaying white/gray.  The music visualization in the Radio app is a little boring with just white bars, and scrolling text color is limited to white so you can&amp;rsquo;t use message color as additional information.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;unspecified.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The display is not designed for wall mounting.  Because the USB power jack is on the back of the display and the USB cable included plugs straight in, the display can&amp;rsquo;t sit up against a wall.  It needs about 1.5&amp;rdquo; (3.8cm) clearance for the USB cable - about the same thickness of the display.  The back seems to be the only logical place to put the USB jack to support scrolling a message across multiple displays, but including a USB cable with a right-angle plug would have kept a lower profile when the display is plugged in.&lt;/p&gt;

&lt;p&gt;The three buttons on the top (left, right, action) are easy to press and have nice tactile feedback.  The volume and power buttons are on the sides, and it takes extra effort to keep the display from sliding sideways on the table when pressing these buttons.  Either I need to hold the display from the other side with a second hand, or press down on the top of the display without accidentally pressing a top button to change the volume.  Maybe the displays that come with a battery are heavy enough to resist sliding when pushing buttons from the side.&lt;/p&gt;

&lt;h2 id=&#34;usage:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Usage&lt;/h2&gt;

&lt;p&gt;I tried the built-in Clock, Weather, Stopwatch, and Timer apps, and they work well.  You can set the alarm or the initial timer value right from the display or through the app.  More detailed customizations like choosing an icon to display next to the clock, or choosing an alarm sound require the app.&lt;/p&gt;

&lt;p&gt;I loaded the Message Board app which lets you set up to five messages.  Each message has an optional icon and text that stays put the screen if it fits, or scrolls if it&amp;rsquo;s too long.  There&amp;rsquo;s no customization for message cycle time or scrolling text speed, and I felt like both were on the fast side.  With the display placed about a foot to the right of my monitor while typing this review, I felt the movement was distracting me.&lt;/p&gt;

&lt;p&gt;I didn&amp;rsquo;t back the Kickstarter campaign to get a Bluetooth speaker, but that feature was added as a bonus.  The sound quality is decent, but it seems to be missing some features that even my generic Bluetooth speakers have.  When connecting from my iPhone, I need to go into Bluetooth Settings on the phone to add the speaker each time it&amp;rsquo;s enabled, while my other speakers are automatically discovered by the phone when powered on or bluetooth is enabled.  I can&amp;rsquo;t change the volume using the music app on my phone, and have to use the awkward hardware volume buttons, or go into the settings menu of the LaMetric app.  Hopefully these issues can be fixed in a future software update.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;LaMetric%20-%20Bluetooth%20speaker.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The graphic equalizer that shows when audio is playing through bluetooth or online radio has a poor update rate that I don&amp;rsquo;t think tracks well to the music.&lt;/p&gt;

&lt;p&gt;Minor nit-picks:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;There’s no built in night/sleep mode.  If I want to significantly dim the display at night without fully powering off the display, I need to install a third party app from the LaMetric app store built to overcome this shortcoming.&lt;/li&gt;
&lt;li&gt;The sounds on the display are a bit basic or feel outdated.  The sound when changing volume sounds like a keypress from a touch tone phone, and isn&amp;rsquo;t very pleasant.  The default alarm sounds are very tinny, though the speakers are capable of playing high quality music.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;customization:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Customization&lt;/h2&gt;

&lt;p&gt;Though people just started receiving displays, there are more than a few third-party apps in the LaMetric App Store.  It appears you do need some web development experience to make an app.  The display must poll your server or listen to push notifications for updated information and doesn&amp;rsquo;t have the ability to parse data directly from a third-party API.  IFTTT support for customizing the display without coding wasn’t available while writing this review, though it is supposed to be coming.&lt;/p&gt;

&lt;p&gt;User-created apps are limited to displaying indictors, or triggering a server when a button is pressed.  There&amp;rsquo;s no support for creating an app with more complex behavior.  I was hoping to see a &lt;a href=&#34;http://tomato-timer.com&#34;&gt;Pomodoro Timer app&lt;/a&gt;, but that is unlikely unless LaMetric creates this app themselves or adds support for more complex user-created apps.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;DraggedImage.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Icon creation is limited to point and click in the web application or phone app.  There are no import capabilities, so creating or editing an icon - especially an animated icon - is tedious.&lt;/p&gt;

&lt;h2 id=&#34;documentation-and-forums:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Documentation and Forums&lt;/h2&gt;

&lt;p&gt;The documentation in the form of a PDF user guide, FAQ built into the app, and knowledge base seems thorough.&lt;/p&gt;

&lt;p&gt;There is a user forum with mixed participation by LaMetric - some threads have responses, and some threads appear ignored though LaMetric says they are reading everything.&lt;/p&gt;

&lt;h3 id=&#34;issues:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Issues&lt;/h3&gt;

&lt;p&gt;Though the display requires use of the cloud servers, interacting with the display &lt;a href=&#34;https://lametric.freshdesk.com/support/discussions/topics/6000018237&#34;&gt;requires being on the same LAN&lt;/a&gt;, so you can&amp;rsquo;t update the display remotely.  If you want to use the display as a remote-controlled message board, that use case isn&amp;rsquo;t supported and the developers haven&amp;rsquo;t commented on the issue yet.&lt;/p&gt;

&lt;h2 id=&#34;concerns:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Concerns&lt;/h2&gt;

&lt;p&gt;As with a lot of internet-enabled products, the functionality of the device depends on servers in the cloud and an app to be maintained, and there is no option for directly driving the display bypassing the cloud.  If/when support for the display ends, the device becomes a paperweight.&lt;/p&gt;

&lt;h2 id=&#34;conclusions:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;Overall I like the display, and it seems like a has a lot of potential, though the software feels like a beta release.  This is what you might expect with initial deliveries from a Kickstarter campaign, but that is not how it is marketed for new customers paying full price.&lt;/p&gt;

&lt;p&gt;The retail price is quite high: $179 for the unit I&amp;rsquo;m reviewing and $199 for a display with battery, plus $25 shipping.  I&amp;rsquo;m not sure how many people think the stereo Bluetooth speaker and online radio feature is useful, but I would rather have seen a cheaper price without those features.&lt;/p&gt;

&lt;p&gt;Subscribe to get more articles about this and similar displays over the coming months.  I plan to write more about customizing the LaMetric Time after IFTTT support is added, and might do a teardown to see what&amp;rsquo;s inside the hardware.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Raincheck Product Preview</title>
      <link>http://www.connected-displays.com/post/raincheck-product-preview/</link>
      <pubDate>Sun, 01 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>http://www.connected-displays.com/post/raincheck-product-preview/</guid>
      <description>

&lt;p&gt;Raincheck is an umbrella stand that knows if it&amp;rsquo;s going to rain.  It has a WiFi connected LED display to show you the chance of precipitation in the next eight hours, built into a beautiful hand-crafted umbrella stand.&lt;/p&gt;

&lt;iframe width=&#34;640&#34; height=&#34;480&#34; src=&#34;https://www.kickstarter.com/projects/1314258106/raincheck/widget/video.html&#34; frameborder=&#34;0&#34; scrolling=&#34;no&#34;&gt; &lt;/iframe&gt;

&lt;p&gt;I had just finished my first &lt;a href=&#34;https://www.particle.io/prototype#photon&#34;&gt;Particle Photon&lt;/a&gt; project - an indicator to tell if it’s going to rain in the next four hours - when I saw Raincheck in my twitter feed.  I thought it was interesting as Raincheck integrates simple electronics in a well-designed hand-crafted enclosure.&lt;/p&gt;

&lt;h2 id=&#34;hardware:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Hardware&lt;/h2&gt;

&lt;p&gt;Raincheck was initially prototyped with a Raspberry Pi, but is now going to be built with the Particle Photon.  It looks like the LEDs are a strip of WS2812 LEDs (aka NeoPixels).  To drive LEDs continuously it will need to be plugged into the wall, and photos in the press kit show what looks like a 5VDC power supply.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;DSCF0539.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Sometimes projects like these are powered through USB.  The max current draw of eight WS2812s is 480mA, so it&amp;rsquo;s going to be just above the 500mA limit for a standard USB port once you add in the Photon&amp;rsquo;s current draw, though the LEDs can and probably are going to be dimmed.&lt;/p&gt;

&lt;h3 id=&#34;enclosure:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Enclosure&lt;/h3&gt;

&lt;p&gt;The main part of Raincheck is the stand itself, designed and hand-crafted by Nick Jonas.  I have no experience with wood working, but it looks like a lot of thought has gone into the design from the appearance, to protecting the inside from the water, and weighting the stand so it stays upright.  The electronics need to be both at the bottom of the stand to connect power, and the side of the stand where the LEDs are.  A model of the prototype shows a channel in the wood for the LED strip and wires, and a photo shows how there was space left in the bottom to mount the rest of the electronics and a panel-mount power jack.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;comparison.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Compare the unfinished look of the breadboard prototype to the LEDs installed in the stand.  The stand does a great job of hiding the messy electronics behind a beautiful object.  The stand isn&amp;rsquo;t cheap - $299 retail price with a $50 discount for early Kickstarter backers - and likely most of the money is going toward the stand.  The cost of the electronics are probably under $50 buying in low volumes from a US shop like Adafruit, and there&amp;rsquo;s labor involved in assembling them.  I have no idea what the materials cost, and how much one would normally pay for a hand-crafted stand like this - there&amp;rsquo;s nothing to easily compare with online.&lt;/p&gt;

&lt;p&gt;Ideally, the lights in the stand shouldn&amp;rsquo;t draw your attention until you need the information and it should be available at a glance.  Without seeing the stand in person it&amp;rsquo;s hard to judge, but I have some concerns about the lights being distracting.  The LEDs blink blue or white - very intense colors - when there is rain or snow in the forecast.  It doesn&amp;rsquo;t appear that the LEDs are diffused, and they may be quite bright if looked at straight on.  This is a minor concern as they are low to the ground, but they also might cast light against a nearby wall, lighting up the room at night even if they are dim.&lt;/p&gt;

&lt;h3 id=&#34;hiding-the-photon-in-an-enclosure:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Hiding the Photon in an Enclosure&lt;/h3&gt;

&lt;p&gt;To meet the Particle &lt;a href=&#34;https://docs.particle.io/guide/how-to-build-a-product/pcb-design/#hardware-design-requirements&#34;&gt;Hardware Design Requirements&lt;/a&gt;, the device must expose the RGB LED and a button to enter setup mode to the user.  On a finished product like this, exposing part of the Photon to make the button user-accessible is risky, especially on the bottom which end up damp (not from the stand leaking water from the umbrella, but from wet rain boots sitting next to the stand).  This hand-crafted product won&amp;rsquo;t have the volume to justify a completely custom PCB using a Particle P0 or P1 module and will likely be using the Photon directly.  The Photon has pads on the back to bring out the signals for an external Setup button and RGB LED, so it&amp;rsquo;s possible to protect the Photon by hiding it deeper in an enclosure, while still giving the user access to setup the Photon.&lt;/p&gt;

&lt;h2 id=&#34;software:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Software&lt;/h2&gt;

&lt;p&gt;Raincheck connects to WiFi, and is configured through an iOS or Android App.  It pulls weather data from the &lt;a href=&#34;https://developer.forecast.io/&#34;&gt;Forecast.io API&lt;/a&gt; every fifteen minutes.&lt;/p&gt;

&lt;h3 id=&#34;api:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;API&lt;/h3&gt;

&lt;p&gt;Why is the forecast updated only every fifteen minutes?  (In my Photon rain project I updated every two minutes.)  Probably because once you get past the Forecast.io’s free 1,000 API requests per day, each request costs money: $0.0001 ea.  That&amp;rsquo;s about $3.50 per year per stand, while updating every 2 minutes for example would cost over $26 per year.  There&amp;rsquo;s no subscription fee for the stand, so these costs have to be built into the price.&lt;/p&gt;

&lt;h3 id=&#34;app:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;App&lt;/h3&gt;

&lt;p&gt;The stand must be configured through a smartphone app.  This seems reasonable as smartphones are so common now, and Particle makes it easy to configure the Photon through an app.  For custom products, Particle has mobile SDKs and example apps, that are supposed to make it easier for developers.  This product needs at least a simple custom app for setting up WiFi credentials and sending your location to the Photon.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Raincheck looks like a well designed product, though at the price point seems only accessible to someone who is willing to pay the premium for a hand-crafted product.  This is reasonable as Nick is hand making these on the side, and the goal of the project seems more about creating a high-quality product and releasing it to the world than to manufacture a ton of products and create a full-time business.  I wish Nick luck with the Kickstarter and hope to see future product designs combining hand-crafted objects with glanceable information.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>